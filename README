ActsAsRestricted
================

Restrict read/write access to your active record classes via a dynamically created Restricted namespace.

so you can use your models exactly as normal but if you wish preface the Restricted namespace to restrict access:

Restricted::Message.find(:all)

Preamble
========

In a pure OO world you should be doing:

    user.<model>.find(....)

    or you will do a lot, especially using has_many through an so on:

    user.messages
    user.message << message etc etc

But doing stuff like this:

    user.messages.find(:joins "LEFT OUTER ...", :select => 'messages.*', :conditions => 'messages.read = true' ....)

looks a bit unreadable.. and then how do you easily restrict writes to the objects you get back ?

Also if you look at most ruby code in controllers, even autogenerated scaffold code its doing Model.find everywhere.

So the philosphy I used, is where possible when trying to get data I do user.<data model> but where I can't, or it makes less sense I use Restricted::<Model>.find..

which effectively does the same thing but also returns a restricted object and I beleive is actually more readable.

Also you can easily put restrictions into exiting code that is probably unsecure by just adding the namespace and changing nothing else.. so its really easy to plugin and works with everything else you might have.

Also your riestrictions might not be based on the user! it could be based on something different for each model.. so more flexibility/extensiblity and more power.

Example
=======

install plugin

add the following line to your class:

   acts_as_restricted :read => true, :write => true

the options instruct whether to restrict access to read or write, by default both are set to true.
Also by default acts_as_restricted will restrict all access.

you can set specific conditions for reading and writing in the class by optionally adding these functions:

this example is from my project currently using the plugin and restricts read/write access to messages and received messages.

  acts_as_restricted :read => true, :write => true

  before_save
      restricted_before_save # this is a work around for the moment needed to enabled restricted write
  end

  def restricted_write_condition
      if current_user.id != self.sender_uid
        raise "Message: write not allowed"
      end
  end

  def self.restricted_condition
      if current_user
        "sender_uid = #{current_user.id} or message_recipients.recipient_uid = #{current_user.id}"
      else
         ActsAsRestricted::SQL_NO_ACCESS # actually this is just "0"
      end
  end

  def self.restricted_join
      "LEFT OUTER JOIN message_recipients ON message_recipients.message_id = messages.id"
  end

  def self.restricted_select
      "messages.*"
  end

Both default_condition and default_join allow you to add conditions or joins to finders with scope and keep all existing joins etc intact.

the current_user function is also made available and grabs from the current thread:Thread.current['user']

the plugin allows you to limit data retrieved, you completely restrict, or return subsets of data. You can also control writes to data (including create)

Examples
========

Write
-----

>>  Thread.current['user'] = User.find_by_id(1)

>> m2 = Restricted::Message.find_by_subject("test")
=> #<Restricted::Message id: nil, date: "2008-08-13 18:03:01", subject: "test", content: "test", sender_uid: 3>
>> m2.save

RuntimeError: ActsAsRestricted: save not allowed

Find
----

>> Message.find(:all).size
=> 7
>> Restricted::Message.find(:all).size
=> 3

>> Message.find(:all, :joins => 'LEFT OUTER JOIN users on users.id = messages.sender_uid', :conditions => 'users.id = 3').size
=> 6

Finders with options

>> Restricted::Message.find(:all, :joins => 'LEFT OUTER JOIN users on users.id = messages.sender_uid', :conditions => 'users.id = 3').size
=> 3

produces the following SQL:

  Restricted::Message Load (0.001001)   SELECT `messages`.* FROM `messages` LEFT OUTER JOIN users on users.id = messages.sender_uid LEFT OUTER JOIN message_recipients ON message_recipients.message_id = messages.id WHERE (sender_uid = 1 or message_recipients.recipient_uid = 1) AND (users.id = 3) 

find_by, count and all other options work too as per normal.

TODO
====

Bits of the code are still slightly hacky, nothing too serious, just still an early version.

Copyright (c) 2008 [Stephen Strudwick], released under the MIT license
